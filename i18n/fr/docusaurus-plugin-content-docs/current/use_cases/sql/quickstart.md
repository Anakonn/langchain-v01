---
sidebar_position: 0
translated: true
---

# D√©marrage rapide

Dans ce guide, nous allons passer en revue les moyens de base pour cr√©er une cha√Æne de questions-r√©ponses et un agent sur une base de donn√©es SQL. Ces syst√®mes nous permettront de poser une question sur les donn√©es d'une base de donn√©es SQL et d'obtenir une r√©ponse en langage naturel. La principale diff√©rence entre les deux est que notre agent peut interroger la base de donn√©es en boucle autant de fois que n√©cessaire pour r√©pondre √† la question.

## ‚ö†Ô∏è Note de s√©curit√© ‚ö†Ô∏è

La cr√©ation de syst√®mes de questions-r√©ponses sur des bases de donn√©es SQL n√©cessite l'ex√©cution de requ√™tes SQL g√©n√©r√©es par le mod√®le. Il y a des risques inh√©rents √† cela. Assurez-vous que les autorisations de connexion √† votre base de donn√©es soient toujours d√©finies de mani√®re aussi restreinte que possible pour les besoins de votre cha√Æne/agent. Cela att√©nuera mais n'√©liminera pas les risques de cr√©ation d'un syst√®me pilot√© par un mod√®le. Pour plus d'informations sur les meilleures pratiques de s√©curit√© g√©n√©rales, [voir ici](/docs/security).

## Architecture

√Ä un niveau √©lev√©, les √©tapes de toute cha√Æne et agent SQL sont :

1. **Convertir la question en requ√™te SQL** : Le mod√®le convertit l'entr√©e de l'utilisateur en une requ√™te SQL.
2. **Ex√©cuter la requ√™te SQL** : Ex√©cuter la requ√™te SQL.
3. **R√©pondre √† la question** : Le mod√®le r√©pond √† l'entr√©e de l'utilisateur en utilisant les r√©sultats de la requ√™te.

![sql_usecase.png](../../../../../../static/img/sql_usecase.png)

## Configuration

Tout d'abord, obtenez les packages requis et d√©finissez les variables d'environnement :

```python
%pip install --upgrade --quiet  langchain langchain-community langchain-openai
```

Nous utiliserons un mod√®le OpenAI dans ce guide.

```python
import getpass
import os

os.environ["OPENAI_API_KEY"] = getpass.getpass()

# Uncomment the below to use LangSmith. Not required.
# os.environ["LANGCHAIN_API_KEY"] = getpass.getpass()
# os.environ["LANGCHAIN_TRACING_V2"] = "true"
```

L'exemple ci-dessous utilisera une connexion SQLite avec la base de donn√©es Chinook. Suivez [ces √©tapes d'installation](https://database.guide/2-sample-databases-sqlite/) pour cr√©er `Chinook.db` dans le m√™me r√©pertoire que ce notebook :

* Enregistrez [ce fichier](https://raw.githubusercontent.com/lerocha/chinook-database/master/ChinookDatabase/DataSources/Chinook_Sqlite.sql) sous `Chinook_Sqlite.sql`
* Ex√©cutez `sqlite3 Chinook.db`
* Ex√©cutez `.read Chinook_Sqlite.sql`
* Testez `SELECT * FROM Artist LIMIT 10;`

Maintenant, `Chinhook.db` est dans notre r√©pertoire et nous pouvons l'interfacer en utilisant la classe `SQLDatabase` pilot√©e par SQLAlchemy :

```python
from langchain_community.utilities import SQLDatabase

db = SQLDatabase.from_uri("sqlite:///Chinook.db")
print(db.dialect)
print(db.get_usable_table_names())
db.run("SELECT * FROM Artist LIMIT 10;")
```

```output
sqlite
['Album', 'Artist', 'Customer', 'Employee', 'Genre', 'Invoice', 'InvoiceLine', 'MediaType', 'Playlist', 'PlaylistTrack', 'Track']
```

```output
"[(1, 'AC/DC'), (2, 'Accept'), (3, 'Aerosmith'), (4, 'Alanis Morissette'), (5, 'Alice In Chains'), (6, 'Ant√¥nio Carlos Jobim'), (7, 'Apocalyptica'), (8, 'Audioslave'), (9, 'BackBeat'), (10, 'Billy Cobham')]"
```

Super! Nous avons une base de donn√©es SQL que nous pouvons interroger. Maintenant, essayons de la connecter √† un LLM.

## Cha√Æne

Cr√©ons une simple cha√Æne qui prend une question, la transforme en requ√™te SQL, ex√©cute la requ√™te et utilise le r√©sultat pour r√©pondre √† la question originale.

### Convertir la question en requ√™te SQL

La premi√®re √©tape d'une cha√Æne ou d'un agent SQL est de prendre l'entr√©e de l'utilisateur et de la convertir en une requ√™te SQL. LangChain propose une cha√Æne int√©gr√©e pour cela : [create_sql_query_chain](https://api.python.langchain.com/en/latest/chains/langchain.chains.sql_database.query.create_sql_query_chain.html).

```python
from langchain.chains import create_sql_query_chain
from langchain_openai import ChatOpenAI

llm = ChatOpenAI(model="gpt-3.5-turbo", temperature=0)
chain = create_sql_query_chain(llm, db)
response = chain.invoke({"question": "How many employees are there"})
response
```

```output
'SELECT COUNT(*) FROM Employee'
```

Nous pouvons ex√©cuter la requ√™te pour nous assurer qu'elle est valide :

```python
db.run(response)
```

```output
'[(8,)]'
```

Nous pouvons regarder la [trace LangSmith](https://smith.langchain.com/public/c8fa52ea-be46-4829-bde2-52894970b830/r) pour mieux comprendre ce que fait cette cha√Æne. Nous pouvons √©galement inspecter directement la cha√Æne pour ses prompts. En regardant le prompt (ci-dessous), nous pouvons voir qu'il est :

* Sp√©cifique au dialecte. Dans ce cas, il fait explicitement r√©f√©rence √† SQLite.
* Contient des d√©finitions pour toutes les tables disponibles.
* Contient trois lignes d'exemples pour chaque table.

Cette technique est inspir√©e par des articles comme [celui-ci](https://arxiv.org/pdf/2204.00498.pdf), qui sugg√®rent que montrer des exemples de lignes et √™tre explicite sur les tables am√©liore les performances. Nous pouvons √©galement inspecter le prompt complet comme ceci :

```python
chain.get_prompts()[0].pretty_print()
```

```output
You are a SQLite expert. Given an input question, first create a syntactically correct SQLite query to run, then look at the results of the query and return the answer to the input question.
Unless the user specifies in the question a specific number of examples to obtain, query for at most 5 results using the LIMIT clause as per SQLite. You can order the results to return the most informative data in the database.
Never query for all columns from a table. You must query only the columns that are needed to answer the question. Wrap each column name in double quotes (") to denote them as delimited identifiers.
Pay attention to use only the column names you can see in the tables below. Be careful to not query for columns that do not exist. Also, pay attention to which column is in which table.
Pay attention to use date('now') function to get the current date, if the question involves "today".

Use the following format:

Question: Question here
SQLQuery: SQL Query to run
SQLResult: Result of the SQLQuery
Answer: Final answer here

Only use the following tables:
[33;1m[1;3m{table_info}[0m

Question: [33;1m[1;3m{input}[0m
```

### Ex√©cuter la requ√™te SQL

Maintenant que nous avons g√©n√©r√© une requ√™te SQL, nous voulons l'ex√©cuter. **C'est la partie la plus dangereuse de la cr√©ation d'une cha√Æne SQL.** R√©fl√©chissez bien si c'est acceptable d'ex√©cuter des requ√™tes automatis√©es sur vos donn√©es. Minimisez autant que possible les autorisations de connexion √† la base de donn√©es. Envisagez d'ajouter une √©tape d'approbation humaine √† vos cha√Ænes avant l'ex√©cution de la requ√™te (voir ci-dessous).

Nous pouvons utiliser l'outil `QuerySQLDatabaseTool` pour ajouter facilement l'ex√©cution de requ√™tes √† notre cha√Æne :

```python
from langchain_community.tools.sql_database.tool import QuerySQLDataBaseTool

execute_query = QuerySQLDataBaseTool(db=db)
write_query = create_sql_query_chain(llm, db)
chain = write_query | execute_query
chain.invoke({"question": "How many employees are there"})
```

```output
'[(8,)]'
```

### R√©pondre √† la question

Maintenant que nous avons un moyen de g√©n√©rer et d'ex√©cuter automatiquement des requ√™tes, nous devons simplement combiner la question originale et le r√©sultat de la requ√™te pour g√©n√©rer une r√©ponse finale. Nous pouvons le faire en passant la question et le r√©sultat au LLM une fois de plus :

```python
from operator import itemgetter

from langchain_core.output_parsers import StrOutputParser
from langchain_core.prompts import PromptTemplate
from langchain_core.runnables import RunnablePassthrough

answer_prompt = PromptTemplate.from_template(
    """Given the following user question, corresponding SQL query, and SQL result, answer the user question.

Question: {question}
SQL Query: {query}
SQL Result: {result}
Answer: """
)

answer = answer_prompt | llm | StrOutputParser()
chain = (
    RunnablePassthrough.assign(query=write_query).assign(
        result=itemgetter("query") | execute_query
    )
    | answer
)

chain.invoke({"question": "How many employees are there"})
```

```output
'There are 8 employees.'
```

### Prochaines √©tapes

Pour une g√©n√©ration de requ√™tes plus complexe, nous pourrions vouloir cr√©er des prompts few-shot ou ajouter des √©tapes de v√©rification des requ√™tes. Pour des techniques avanc√©es comme celles-ci et plus encore, consultez :

* [Strat√©gies de prompt](/docs/use_cases/sql/prompting) : Techniques avanc√©es d'ing√©nierie de prompt.
* [V√©rification des requ√™tes](/docs/use_cases/sql/query_checking) : Ajouter la validation des requ√™tes et la gestion des erreurs.
* [Grandes bases de donn√©es](/docs/use_cases/sql/large_db) : Techniques pour travailler avec de grandes bases de donn√©es.

## Agents

LangChain poss√®de un agent SQL qui offre un moyen plus flexible d'interagir avec les bases de donn√©es SQL. Les principaux avantages de l'utilisation de l'agent SQL sont :

- Il peut r√©pondre √† des questions bas√©es sur le sch√©ma des bases de donn√©es ainsi que sur le contenu des bases de donn√©es (comme d√©crire une table sp√©cifique).
- Il peut se remettre d'erreurs en ex√©cutant une requ√™te g√©n√©r√©e, en capturant la traceback et en la r√©g√©n√©rant correctement.
- Il peut r√©pondre √† des questions n√©cessitant plusieurs requ√™tes d√©pendantes.
- Il √©conomisera des jetons en ne consid√©rant que le sch√©ma des tables pertinentes.

Pour initialiser l'agent, nous utilisons la fonction `create_sql_agent`. Cet agent contient la `SQLDatabaseToolkit` qui contient des outils pour :

* Cr√©er et ex√©cuter des requ√™tes
* V√©rifier la syntaxe des requ√™tes
* R√©cup√©rer des descriptions de tables
* ... et plus encore

### Initialisation de l'agent

```python
from langchain_community.agent_toolkits import create_sql_agent

agent_executor = create_sql_agent(llm, db=db, agent_type="openai-tools", verbose=True)
```

```python
agent_executor.invoke(
    {
        "input": "List the total sales per country. Which country's customers spent the most?"
    }
)
```

```output


[1m> Entering new AgentExecutor chain...[0m
[32;1m[1;3m
Invoking: `sql_db_list_tables` with `{}`


[0m[38;5;200m[1;3mAlbum, Artist, Customer, Employee, Genre, Invoice, InvoiceLine, MediaType, Playlist, PlaylistTrack, Track[0m[32;1m[1;3m
Invoking: `sql_db_schema` with `Invoice,Customer`


[0m[33;1m[1;3m
CREATE TABLE "Customer" (
	"CustomerId" INTEGER NOT NULL,
	"FirstName" NVARCHAR(40) NOT NULL,
	"LastName" NVARCHAR(20) NOT NULL,
	"Company" NVARCHAR(80),
	"Address" NVARCHAR(70),
	"City" NVARCHAR(40),
	"State" NVARCHAR(40),
	"Country" NVARCHAR(40),
	"PostalCode" NVARCHAR(10),
	"Phone" NVARCHAR(24),
	"Fax" NVARCHAR(24),
	"Email" NVARCHAR(60) NOT NULL,
	"SupportRepId" INTEGER,
	PRIMARY KEY ("CustomerId"),
	FOREIGN KEY("SupportRepId") REFERENCES "Employee" ("EmployeeId")
)

/*
3 rows from Customer table:
CustomerId	FirstName	LastName	Company	Address	City	State	Country	PostalCode	Phone	Fax	Email	SupportRepId
1	Lu√≠s	Gon√ßalves	Embraer - Empresa Brasileira de Aeron√°utica S.A.	Av. Brigadeiro Faria Lima, 2170	S√£o Jos√© dos Campos	SP	Brazil	12227-000	+55 (12) 3923-5555	+55 (12) 3923-5566	luisg@embraer.com.br	3
2	Leonie	K√∂hler	None	Theodor-Heuss-Stra√üe 34	Stuttgart	None	Germany	70174	+49 0711 2842222	None	leonekohler@surfeu.de	5
3	Fran√ßois	Tremblay	None	1498 rue B√©langer	Montr√©al	QC	Canada	H2G 1A7	+1 (514) 721-4711	None	ftremblay@gmail.com	3
*/


CREATE TABLE "Invoice" (
	"InvoiceId" INTEGER NOT NULL,
	"CustomerId" INTEGER NOT NULL,
	"InvoiceDate" DATETIME NOT NULL,
	"BillingAddress" NVARCHAR(70),
	"BillingCity" NVARCHAR(40),
	"BillingState" NVARCHAR(40),
	"BillingCountry" NVARCHAR(40),
	"BillingPostalCode" NVARCHAR(10),
	"Total" NUMERIC(10, 2) NOT NULL,
	PRIMARY KEY ("InvoiceId"),
	FOREIGN KEY("CustomerId") REFERENCES "Customer" ("CustomerId")
)

/*
3 rows from Invoice table:
InvoiceId	CustomerId	InvoiceDate	BillingAddress	BillingCity	BillingState	BillingCountry	BillingPostalCode	Total
1	2	2009-01-01 00:00:00	Theodor-Heuss-Stra√üe 34	Stuttgart	None	Germany	70174	1.98
2	4	2009-01-02 00:00:00	Ullev√•lsveien 14	Oslo	None	Norway	0171	3.96
3	8	2009-01-03 00:00:00	Gr√©trystraat 63	Brussels	None	Belgium	1000	5.94
*/[0m[32;1m[1;3m
Invoking: `sql_db_query` with `SELECT c.Country, SUM(i.Total) AS TotalSales FROM Invoice i JOIN Customer c ON i.CustomerId = c.CustomerId GROUP BY c.Country ORDER BY TotalSales DESC LIMIT 10;`
responded: To list the total sales per country, I can query the "Invoice" and "Customer" tables. I will join these tables on the "CustomerId" column and group the results by the "BillingCountry" column. Then, I will calculate the sum of the "Total" column to get the total sales per country. Finally, I will order the results in descending order of the total sales.

Here is the SQL query:

\```sql
SELECT c.Country, SUM(i.Total) AS TotalSales
FROM Invoice i
JOIN Customer c ON i.CustomerId = c.CustomerId
GROUP BY c.Country
ORDER BY TotalSales DESC
LIMIT 10;
\```

Now, I will execute this query to get the total sales per country.

[0m[36;1m[1;3m[('USA', 523.0600000000003), ('Canada', 303.9599999999999), ('France', 195.09999999999994), ('Brazil', 190.09999999999997), ('Germany', 156.48), ('United Kingdom', 112.85999999999999), ('Czech Republic', 90.24000000000001), ('Portugal', 77.23999999999998), ('India', 75.25999999999999), ('Chile', 46.62)][0m[32;1m[1;3mThe total sales per country are as follows:

1. USA: $523.06
2. Canada: $303.96
3. France: $195.10
4. Brazil: $190.10
5. Germany: $156.48
6. United Kingdom: $112.86
7. Czech Republic: $90.24
8. Portugal: $77.24
9. India: $75.26
10. Chile: $46.62

To answer the second question, the country whose customers spent the most is the USA, with a total sales of $523.06.[0m

[1m> Finished chain.[0m

```

```output
{'input': "List the total sales per country. Which country's customers spent the most?",
 'output': 'The total sales per country are as follows:\n\n1. USA: $523.06\n2. Canada: $303.96\n3. France: $195.10\n4. Brazil: $190.10\n5. Germany: $156.48\n6. United Kingdom: $112.86\n7. Czech Republic: $90.24\n8. Portugal: $77.24\n9. India: $75.26\n10. Chile: $46.62\n\nTo answer the second question, the country whose customers spent the most is the USA, with a total sales of $523.06.'}
```

```python
agent_executor.invoke({"input": "Describe the playlisttrack table"})
```

```output


[1m> Entering new AgentExecutor chain...[0m
[32;1m[1;3m
Invoking: `sql_db_list_tables` with `{}`


[0m[38;5;200m[1;3mAlbum, Artist, Customer, Employee, Genre, Invoice, InvoiceLine, MediaType, Playlist, PlaylistTrack, Track[0m[32;1m[1;3m
Invoking: `sql_db_schema` with `PlaylistTrack`


[0m[33;1m[1;3m
CREATE TABLE "PlaylistTrack" (
	"PlaylistId" INTEGER NOT NULL,
	"TrackId" INTEGER NOT NULL,
	PRIMARY KEY ("PlaylistId", "TrackId"),
	FOREIGN KEY("TrackId") REFERENCES "Track" ("TrackId"),
	FOREIGN KEY("PlaylistId") REFERENCES "Playlist" ("PlaylistId")
)

/*
3 rows from PlaylistTrack table:
PlaylistId	TrackId
1	3402
1	3389
1	3390
*/[0m[32;1m[1;3mThe `PlaylistTrack` table has two columns: `PlaylistId` and `TrackId`. It is a junction table that represents the many-to-many relationship between playlists and tracks.

Here is the schema of the `PlaylistTrack` table:

\```

CREATE TABLE "PlaylistTrack" (
	"PlaylistId" INTEGER NOT NULL,
	"TrackId" INTEGER NOT NULL,
	PRIMARY KEY ("PlaylistId", "TrackId"),
	FOREIGN KEY("TrackId") REFERENCES "Track" ("TrackId"),
	FOREIGN KEY("PlaylistId") REFERENCES "Playlist" ("PlaylistId")
)

\```

The `PlaylistId` column is a foreign key referencing the `PlaylistId` column in the `Playlist` table. The `TrackId` column is a foreign key referencing the `TrackId` column in the `Track` table.

Here are three sample rows from the `PlaylistTrack` table:

\```

PlaylistId   TrackId
1            3402
1            3389
1            3390

\```

Please let me know if there is anything else I can help with.[0m

[1m> Finished chain.[0m
```

```output
{'input': 'Describe the playlisttrack table',
 'output': 'The `PlaylistTrack` table has two columns: `PlaylistId` and `TrackId`. It is a junction table that represents the many-to-many relationship between playlists and tracks. \n\nHere is the schema of the `PlaylistTrack` table:\n\n```\nCREATE TABLE "PlaylistTrack" (\n\t"PlaylistId" INTEGER NOT NULL, \n\t"TrackId" INTEGER NOT NULL, \n\tPRIMARY KEY ("PlaylistId", "TrackId"), \n\tFOREIGN KEY("TrackId") REFERENCES "Track" ("TrackId"), \n\tFOREIGN KEY("PlaylistId") REFERENCES "Playlist" ("PlaylistId")\n)\n```\n\nThe `PlaylistId` column is a foreign key referencing the `PlaylistId` column in the `Playlist` table. The `TrackId` column is a foreign key referencing the `TrackId` column in the `Track` table.\n\nHere are three sample rows from the `PlaylistTrack` table:\n\n```\nPlaylistId   TrackId\n1            3402\n1            3389\n1            3390\n```\n\nPlease let me know if there is anything else I can help with.'}
```

### Prochaines √©tapes

Pour plus d'informations sur l'utilisation et la personnalisation des agents, rendez-vous sur la page [Agents](/docs/use_cases/sql/agents).
