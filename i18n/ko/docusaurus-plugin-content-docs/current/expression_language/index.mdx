---
sidebar_class_name: hidden
translated: true
---

# LangChain 표현 언어 (LCEL)

LangChain 표현 언어(LCEL)는 체인을 쉽게 구성할 수 있는 선언적인 방법입니다.
LCEL은 가장 간단한 "프롬프트 + LLM" 체인부터 가장 복잡한 체인까지 **코드 변경 없이 프로토타입을 프로덕션에 배포할 수 있도록 설계되었습니다** (일부 사용자는 100단계 이상의 LCEL 체인을 프로덕션에서 성공적으로 실행하고 있습니다). LCEL을 사용해야 하는 몇 가지 이유를 강조하자면:

[**일급 스트리밍 지원**](/docs/expression_language/streaming)
LCEL로 체인을 구축하면 첫 번째 토큰까지의 시간을 최적화할 수 있습니다. 일부 체인의 경우 LLM에서 스트리밍 출력 파서로 직접 토큰을 스트리밍하여, LLM 제공자가 원시 토큰을 출력하는 속도와 동일한 속도로 구문 분석된 증분 출력 청크를 얻을 수 있습니다.

[**비동기 지원**](/docs/expression_language/interface)
LCEL로 구축된 모든 체인은 동기 API(예: 프로토타입 작성 중 Jupyter 노트북)와 비동기 API(예: [LangServe](/docs/langserve) 서버)를 모두 사용할 수 있습니다. 이를 통해 프로토타입 및 프로덕션에서 동일한 코드를 사용하여 뛰어난 성능을 제공하고 동일한 서버에서 여러 동시 요청을 처리할 수 있습니다.

[**최적화된 병렬 실행**](/docs/expression_language/primitives/parallel)
LCEL 체인의 단계가 병렬로 실행될 수 있는 경우(예: 여러 검색기에서 문서를 가져오는 경우) 동기 및 비동기 인터페이스 모두에서 자동으로 수행되어 가능한 가장 낮은 지연 시간을 제공합니다.

[**재시도 및 폴백**](/docs/guides/productionization/fallbacks)
LCEL 체인의 어느 부분에든 재시도 및 폴백을 구성할 수 있습니다. 이는 체인의 신뢰성을 확장하는 데 큰 도움이 됩니다. 현재 스트리밍 지원을 위한 재시도/폴백을 추가하고 있어 지연 시간 비용 없이 추가 신뢰성을 얻을 수 있습니다.

[**중간 결과 액세스**](/docs/expression_language/interface#async-stream-events-beta)
복잡한 체인의 경우 최종 출력이 생성되기 전에 중간 단계의 결과에 액세스하는 것이 매우 유용할 수 있습니다. 이는 최종 사용자에게 무언가 진행 중임을 알리거나 체인을 디버그하는 데 사용할 수 있습니다. 중간 결과를 스트리밍할 수 있으며, 이는 모든 [LangServe](/docs/langserve) 서버에서 사용할 수 있습니다.

[**입력 및 출력 스키마**](/docs/expression_language/interface#input-schema)
입력 및 출력 스키마는 체인의 구조에서 추론된 Pydantic 및 JSONSchema 스키마를 모든 LCEL 체인에 제공합니다. 이는 입력 및 출력의 유효성을 검사하는 데 사용할 수 있으며 LangServe의 필수적인 부분입니다.

[**원활한 LangSmith 추적**](/docs/langsmith)
체인이 점점 더 복잡해짐에 따라 각 단계에서 정확히 무엇이 일어나는지 이해하는 것이 점점 더 중요해집니다.
LCEL을 사용하면 **모든** 단계가 최대 가시성과 디버그 가능성을 위해 [LangSmith](/docs/langsmith/)에 자동으로 기록됩니다.

[**원활한 LangServe 배포**](/docs/langserve)
LCEL로 생성된 모든 체인은 [LangServe](/docs/langserve)를 사용하여 쉽게 배포할 수 있습니다.