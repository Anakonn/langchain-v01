---
sidebar_class_name: hidden
sidebar_position: 1
translated: true
---

# स्टोर्स

कई अलग-अलग एप्लिकेशन में, कुछ प्रकार की कुंजी-मूल्य संग्रह होना लाभदायक है।
इस खंड में, हम `ByteStore` इंटरफ़ेस के कुछ अलग-अलग कार्यान्वयनों का उपयोग करके कुंजी-मूल्य युग्मों को संग्रहीत करने के कुछ तरीकों पर नज़र डालेंगे।

## सुविधाएं (मूल रूप से समर्थित)

सभी `ByteStore` निम्नलिखित कार्यों का समर्थन करते हैं, जिनका उपयोग **एक साथ** कई कुंजी-मूल्य युग्मों को संशोधित करने के लिए किया जाता है:

- `mget(key: Sequence[str]) -> List[Optional[bytes]]`: कई कुंजियों का सामग्री प्राप्त करें, यदि कुंजी मौजूद नहीं है तो `None` लौटाएं
- `mset(key_value_pairs: Sequence[Tuple[str, bytes]]) -> None`: कई कुंजियों का सामग्री सेट करें
- `mdelete(key: Sequence[str]) -> None`: कई कुंजियों को हटाएं
- `yield_keys(prefix: Optional[str] = None) -> Iterator[str]`: स्टोर में सभी कुंजियों को प्रदान करें, वैकल्पिक रूप से किसी उपसर्ग द्वारा फ़िल्टर करें

## किसे चुनें

`ByteStore` को आपसी रूप से बदलने योग्य डिज़ाइन किया गया है। डिफ़ॉल्ट रूप से, अधिकांश निर्भर एकीकरण `InMemoryByteStore` का उपयोग करते हैं, जो एक सरल मेमोरी-आधारित कुंजी-मूल्य स्टोर है।

हालांकि, यदि आपके पास अन्य आवश्यकताएं हैं, जैसे कि विशाल स्केलेबिलिटी या स्थायित्व, तो आप इस खंड में प्रलेखित अन्य `ByteStore` कार्यान्वयन के साथ बदल सकते हैं।
