---
translated: true
---

यह टेम्पलेट एडवांस्ड पुनर्प्राप्ति रणनीतियों को लागू करके सटीक एम्बेडिंग और संदर्भ संरक्षण को संतुलित करने की अनुमति देता है।

## रणनीतियाँ

1. **टाइपिकल RAG**:
   - पारंपरिक विधि जहां सटीक डेटा अनुक्रमित किया गया है वही पुनर्प्राप्त किया जाता है।
2. **पेरेंट रिट्रीवर**:
   - पूरे दस्तावेजों को अनुक्रमित करने के बजाय, डेटा को छोटे टुकड़ों में विभाजित किया जाता है, जिन्हें पेरेंट और चाइल्ड दस्तावेज कहा जाता है।
   - विशिष्ट अवधारणाओं का बेहतर प्रतिनिधित्व सुनिश्चित करने के लिए चाइल्ड दस्तावेज अनुक्रमित किए जाते हैं, जबकि संदर्भ संरक्षण सुनिश्चित करने के लिए पेरेंट दस्तावेज पुनर्प्राप्त किए जाते हैं।
3. **हाइपोथेटिकल प्रश्न**:
     - दस्तावेजों को उन संभावित प्रश्नों को निर्धारित करने के लिए प्रोसेस किया जाता है जिनका वे उत्तर दे सकते हैं।
     - इन प्रश्नों को विशिष्ट अवधारणाओं का बेहतर प्रतिनिधित्व सुनिश्चित करने के लिए अनुक्रमित किया जाता है, जबकि संदर्भ संरक्षण सुनिश्चित करने के लिए पेरेंट दस्तावेज पुनर्प्राप्त किए जाते हैं।
4. **सारांश**:
     - पूरे दस्तावेज को अनुक्रमित करने के बजाय, दस्तावेज का एक सारांश बनाया और अनुक्रमित किया जाता है।
     - इसी तरह, RAG अनुप्रयोग में पेरेंट दस्तावेज पुनर्प्राप्त किया जाता है।

## वातावरण सेटअप

आपको निम्नलिखित पर्यावरण चर परिभाषित करने की आवश्यकता है।

```shell
OPENAI_API_KEY=<YOUR_OPENAI_API_KEY>
NEO4J_URI=<YOUR_NEO4J_URI>
NEO4J_USERNAME=<YOUR_NEO4J_USERNAME>
NEO4J_PASSWORD=<YOUR_NEO4J_PASSWORD>
```

## डेटा से भरना

यदि आप कुछ उदाहरण डेटा से डीबी को भरना चाहते हैं, तो आप `python ingest.py` चला सकते हैं।
स्क्रिप्ट `dune.txt` फ़ाइल से पाठ के खंडों को प्रोसेस करती है और उन्हें एक Neo4j ग्राफ डेटाबेस में संग्रहीत करती है।
पहले, पाठ को बड़े टुकड़ों ("पेरेंट") में विभाजित किया जाता है और फिर छोटे टुकड़ों ("बच्चों") में और विभाजित किया जाता है, जहां दोनों पेरेंट और बच्चे टुकड़े संदर्भ बनाए रखने के लिए थोड़ा ओवरलैप करते हैं।
इन टुकड़ों को डेटाबेस में संग्रहीत करने के बाद, OpenAI के एम्बेडिंग का उपयोग करके बच्चे नोड के लिए एम्बेडिंग की गणना की जाती है और भविष्य के पुनर्प्राप्ति या विश्लेषण के लिए ग्राफ में वापस संग्रहीत की जाती है।
प्रत्येक पेरेंट नोड के लिए, संभावित प्रश्नों और सारांशों को उत्पन्न, एम्बेड और डेटाबेस में जोड़ा जाता है।
इसके अलावा, इन एम्बेडिंग को कुशलतापूर्वक क्वेरी करने के लिए प्रत्येक पुनर्प्राप्ति रणनीति के लिए एक वेक्टर इंडेक्स बनाया जाता है।

*ध्यान दें कि LLM की गति के कारण आंकड़ों को भरने में एक या दो मिनट लग सकते हैं।*

## उपयोग

इस पैकेज का उपयोग करने के लिए, आपके पास पहले से LangChain CLI स्थापित होना चाहिए:

```shell
pip install -U "langchain-cli[serve]"
```

एक नया LangChain प्रोजेक्ट बनाने और इसे एकमात्र पैकेज के रूप में स्थापित करने के लिए, आप ऐसा कर सकते हैं:

```shell
langchain app new my-app --package neo4j-advanced-rag
```

यदि आप किसी मौजूदा प्रोजेक्ट में इसे जोड़ना चाहते हैं, तो आप बस यह चला सकते हैं:

```shell
langchain app add neo4j-advanced-rag
```

और अपने `server.py` फ़ाइल में निम्नलिखित कोड जोड़ें:

```python
from neo4j_advanced_rag import chain as neo4j_advanced_chain

add_routes(app, neo4j_advanced_chain, path="/neo4j-advanced-rag")
```

(वैकल्पिक) अब आइए LangSmith को कॉन्फ़िगर करें।
LangSmith हमें LangChain अनुप्रयोगों को ट्रेस, मॉनिटर और डीबग करने में मदद करेगा।
आप [यहाँ](https://smith.langchain.com/) से LangSmith के लिए साइन अप कर सकते हैं।
यदि आपके पास पहुंच नहीं है, तो आप इस खंड को छोड़ सकते हैं।

```shell
export LANGCHAIN_TRACING_V2=true
export LANGCHAIN_API_KEY=<your-api-key>
export LANGCHAIN_PROJECT=<your-project>  # if not specified, defaults to "default"
```

यदि आप इस निर्देशिका के अंदर हैं, तो आप सीधे एक LangServe इंस्टेंस शुरू कर सकते हैं:

```shell
langchain serve
```

यह FastAPI ऐप को शुरू करेगा और सर्वर [http://localhost:8000](http://localhost:8000) पर स्थानीय रूप से चल रहा है।

हम [http://127.0.0.1:8000/docs](http://127.0.0.1:8000/docs) पर सभी टेम्पलेट देख सकते हैं।
हम [http://127.0.0.1:8000/neo4j-advanced-rag/playground](http://127.0.0.1:8000/neo4j-advanced-rag/playground) पर खेल सकते हैं।

हम कोड के साथ टेम्पलेट का उपयोग कर सकते हैं:

```python
from langserve.client import RemoteRunnable

runnable = RemoteRunnable("http://localhost:8000/neo4j-advanced-rag")
```
