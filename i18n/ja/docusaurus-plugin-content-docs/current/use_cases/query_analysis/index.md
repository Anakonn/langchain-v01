---
sidebar_class_name: hidden
translated: true
---

# クエリ分析

"検索"は多くのユースケースに活用されています - 「検索」は、リトリーバル拡張型生成の「検索」部分にも含まれます。これを行う最も簡単な方法は、ユーザーの質問を直接リトリーバーに渡すことです。パフォーマンスを向上させるには、*クエリ分析*を使ってクエリを「最適化」することもできます。これは従来、ルールベースの手法で行われていましたが、LLMの台頭により、LLMを使う方が一般的かつ実現可能になってきています。具体的には、生の質問(またはメッセージのリスト)をLLMに渡し、最適化されたクエリ(通常は文字列で、オプションで他の構造化情報も含む)を返すことができます。

![クエリ分析](../../../../../../static/img/query_analysis.png)

## 解決する問題

クエリ分析は、リトリーバーに送るクエリを最適化するのに役立ちます。これは以下のような場合に当てはまります:

* リトリーバーがデータの特定のフィールドに対して検索とフィルタリングをサポートしており、ユーザー入力がそれらのフィールドを参照している可能性がある場合
* ユーザー入力に複数の異なる質問が含まれている場合
* 関連情報を取得するには複数のクエリが必要な場合
* 検索の質が表現に敏感な場合
* 複数のリトリーバーを検索対象にできる場合で、ユーザー入力がそれらのいずれかを参照している可能性がある場合

問題は様々なので、解決策も異なります。どのクエリ分析手法を使うべきかを判断するには、現在のリトリーバーシステムの問題点を正確に理解する必要があります。これは、現在のアプリケーションの失敗データポイントを見て、共通のテーマを特定することで最もよく行えます。問題点がわかってから、それを解決する方法を検討できます。

## クイックスタート

[クイックスタート](/docs/use_cases/query_analysis/quickstart)に進んで、基本的なエンドツーエンドの例でクエリ分析の使い方を確認してください。LangChain YouTubeビデオのコンテンツ上でサーチエンジンを作成し、生のユーザー質問をそのインデックスに渡した際の問題点と、クエリ分析でそれを解決する方法を示します。クイックスタートでは**クエリ構造化**に焦点を当てています。以下は、データやユースケースに応じて関連する可能性のある追加のクエリ分析手法です。

## 手法

生の質問やメッセージのリストから、より最適化されたクエリを生成するための手法には以下のようなものがあります:

* [クエリ分解](/docs/use_cases/query_analysis/techniques/decomposition): ユーザー入力に複数の異なる質問が含まれている場合、入力を個別に実行される別々のクエリに分解することができます。
* [クエリ拡張](/docs/use_cases/query_analysis/techniques/expansion): インデックスがクエリの表現に敏感な場合、ユーザーの質問をパラフレーズした複数のバージョンを生成して、関連する結果を取得する確率を高めることができます。
* [仮想文書埋め込み(HyDE)](/docs/use_cases/query_analysis/techniques/hyde): ベクトルストアのようなシミラリティ検索ベースのインデックスを使っている場合、生の質問を使って検索すると上手くいかないことがあります。なぜなら、それらの埋め込みは関連文書のものとあまり似ていないからです。その代わりに、モデルに関連文書を生成させ、それを使ってシミラリティ検索を行うと良いかもしれません。
* [クエリルーティング](/docs/use_cases/query_analysis/techniques/routing): 複数のインデックスがあり、ユーザー入力に対して有用なのはそのうちの一部だけの場合、入力を関連するインデックスにのみルーティングすることができます。
* [ステップバックプロンプティング](/docs/use_cases/query_analysis/techniques/step_back): 時には、質問の細かい点によって検索の質やモデルの生成が妨げられることがあります。これに対処する1つの方法は、まず抽象的な「ステップバック」の質問を生成し、オリジナルの質問とステップバックの質問の両方に基づいてクエリを行うことです。
* [クエリ構造化](/docs/use_cases/query_analysis/techniques/structuring): 文書に複数の検索可能/フィルター可能な属性がある場合、生のユーザー入力から、どの特定の属性を検索/フィルターすべきかを推測することができます。例えば、ユーザー入力に動画の公開日に関する情報が含まれている場合、それを `publish_date` 属性のフィルターとして扱うことができます。

## 方法

* [プロンプトに例を追加する](/docs/use_cases/query_analysis/how_to/few_shot): クエリ分析が複雑になるにつれ、プロンプトに例を追加することで、パフォーマンスを大幅に改善できます。
* [高基数カテゴリカル変数に対処する](/docs/use_cases/query_analysis/how_to/high_cardinality): 作成する構造化クエリの多くは、カテゴリカル変数を含みます。潜在的な値が多い場合、これを正しく行うのは難しい場合があります。
* [フィルターを構築する](/docs/use_cases/query_analysis/how_to/constructing-filters): このガイドでは、Pydanticモデルからベクトルストアの特定のクエリ言語でのフィルターを作成する方法を説明しています。
* [複数のクエリを扱う](/docs/use_cases/query_analysis/how_to/multiple_queries): 一部のクエリ分析手法は複数のクエリを生成します。このガイドでは、それらをすべてリトリーバーに渡す方法を説明しています。
* [クエリがない場合の対処](/docs/use_cases/query_analysis/how_to/no_queries): 一部のクエリ分析手法ではクエリが生成されない場合があります。このガイドでは、そのような状況に優雅に対処する方法を説明しています。
* [複数のリトリーバーを扱う](/docs/use_cases/query_analysis/how_to/multiple_retrievers): 一部のクエリ分析手法では、複数のリトリーバー間でのルーティングが関係します。このガイドでは、それを優雅に扱う方法を説明しています。
